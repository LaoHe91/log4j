////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////
= Markers

Markers allow "tag" log statements with a Marker object, labeling them
as belonging to a specific type. For example, developers can use Markers to tag
log statements related to a particular subsystem or functionality.

By using Markers, it is possible to filter log statements based on the Marker
and display only those log statements that are of interest, such as those
related to XML processing or SQL queries.

Markers offer more fine-grained control over log filtering beyond log levels or package names.

[#create]
== Creating Markers

To create a Marker, use the MarkerManager class. The MarkerManager class provides 
a factory method to create a Marker object is used to tag log statements.

[source, java]
----
Marker SQL_MARKER = MarkerManager.getMarker("SQL");
----

Since a `Marker` is reusable across multiple log statements, it makes sense to store the `Marker` in a `static final` field and make it a constant.
Once created, use it as the first argument in the log statement:

[source, java]
----
logger.debug(SQL_MARKER, "Here is my SQL related message");
----

A complete example is shown below. It creates the Marker as the constant
and then uses it to tag a log statement. The log method works "as usual,"
but the marker needs to be added as the first argument.

[source, java]
----
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.MarkerManager;

public class MyApp {

    private static final Logger LOGGER = LogManager.getLogger();

    private static final Marker SQL_MARKER = MarkerManager.getMarker("MY_APP_SQL"); <1>

    public void doQuery(String table) {
        // do business logic here        

        LOGGER.debug(SQL_MARKER, "SELECT * FROM {}", table); <2>
    }
}
----
<1> The marker is created and stored as a constant
<2> Using the marker to tag a log statement

You must create a configuration file to write log statements tagged with the "SQL" marker to the console. 
This file uses the `<MarkerFilter>` element to accept or deny log statements 
based on the marker. 

The following code shows how the MarkerFilter is used in the configuration file. 
It assumes that the Console appender is defined in the configuration file.

[source, xml]
----
<Logger name="com.example" level="all" additivity="false">
    <AppenderRef ref="Console">
        <Filters>
            <MarkerFilter marker="MY_APP_SQL" onMatch="ACCEPT" onMismatch="DENY"/> <1>
        </Filters>
    </AppenderRef>
</Logger>
----
<1> The MarkerFilter is used to accept only SQL markers but deny others

[#hierarchy]
== Parent and child markers

A Marker can have zero or more parent Markers. This allows for a hierarchy of Markers.
To create such a hierarchy, you must use the `setParents` method on the Marker object
after you create the child marker. This method will connect both markers.

[source, java]
----
Marker SQL_MARKER = MarkerManager.getMarker("MY_APP_SQL"); <1>
Marker UPDATE_MARKER = MarkerManager.getMarker("MY_APP_SQL_UPDATE").setParents(SQL_MARKER); <2>
----
<1> Creating the parent marker
<2> Creating the child marker and connecting it to the parent marker

The child marker works as expected by adding to the log method as the first argument.

[source, java]
----
LOGGER.debug(UPDATE_MARKER, "UPDATE {} SET {}", table, values);
----

It is now possible to either filter for the parent, or, be more specific, and filter only for the child marker.

[#pitfalls]
== Pitfalls

It is important to note that marker names must be unique, as they are permanently registered by name. 
Generic marker names should be avoided, as they may conflict with 
those provided by third parties. Except, of course, if the user is aware of the implications.

While parent markers can be added or removed dynamically through the `setParents()' method, 
it is generally advisable to set the parents when the marker is created. 
This is for efficiency and performance reasons. 

It is also worth noting that markers without parents are more efficient to evaluate 
than markers with multiple parents. It is generally a good idea to avoid 
complex hierarchies of markers where possible.
