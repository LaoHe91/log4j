////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////
= Markers

Markers allow "tag" log statements with a
link:../javadoc/log4j-api/org/apache/logging/log4j/Marker.html[`Marker`]
object, labeling them as belonging to a specific type. 
For example, developers can use markers to tag log statements related to a particular subsystem or functionality.

By using markers, it is possible to filter log statements based on the `Marker`
and display only those log statements that are of interest, such as those
related to XML processing or SQL queries.

Markers offer more fine-grained control over log filtering beyond log levels or package names.

[#create]
== Creating Markers

To create a `Marker`, use the `MarkerManager` class as follows:

[source, java]
----
Marker SQL_MARKER = MarkerManager.getMarker("SQL");
----

Since a `Marker` is reusable across multiple log statements, storing it in a `static final` field makes it a constant.
Once created, use it as the first argument in the log statement:

[source, java]
----
logger.debug(SQL_MARKER, "Here is my SQL related message");
----

The example below creates the marker as the constant and then uses it to tag a log statement.
The log method works _as usual_, but the marker needs to be the first argument.

[source, java]
----
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.MarkerManager;

public class MyApp {

    private static final Logger LOGGER = LogManager.getLogger();

    private static final Marker SQL_MARKER = MarkerManager.getMarker("MY_APP_SQL"); <1>

    public void doQuery(String table) {
        // Do business logic here        

        LOGGER.debug(SQL_MARKER, "SELECT * FROM {}", table); <2>
    }
}
----
<1> The marker is created and stored as a constant
<2> Using the marker to tag a log statement

You must create a configuration file to write log statements tagged with the "SQL" marker to the console. 
This file uses the `<MarkerFilter>` element to accept or deny log statements 
based on the marker. 

The following code shows how the `MarkerFilter` is used in the configuration file. 
It assumes that the `Console` appender is defined in the configuration file.

Once a developer tags a log event with a marker, we can apply specialized configuration on that particular marker.
For instance, we can use a xref:manual/filters.adoc#MarkerFilter[`MarkerFilter`] to redirect 
log events whose marker matches a particular name to a dedicated appender.
In the example below, Log4j redirects all `MY_SQL_APP`-marked log messages from the `com.example` package to the `CONSOLE` appender:

[source, xml]
----
<logger name="com.example" level="OFF"><!--1-->
  <AppenderRef ref="CONSOLE">
    <Filters>
      <MarkerFilter marker="MY_APP_SQL" onMatch="ACCEPT" onMismatch="DENY"/><!--2-->
    </Filters>
  </AppenderRef>
</logger>
----
<1> Match all messages from `com.example` package from all levels
<2> Only allow `MY_APP_SQL`-marked messages

[#hierarchy]
== Parent and child markers

A marker can have zero or more parent markers, allowing for a hierarchy of markers.
To create such a hierarchy, you must use the `setParents` method on the `Marker` object
after you create the child marker. This method will connect both markers.

[source, java]
----
Marker SQL_MARKER = MarkerManager.getMarker("MY_APP_SQL"); // <1>
Marker UPDATE_MARKER = MarkerManager.getMarker("MY_APP_SQL_UPDATE").setParents(SQL_MARKER); // <2>
----
<1> Creating the parent marker
<2> Creating the child marker and connecting it to the parent marker

The child marker works as expected by adding to the log method as the first argument.

[source, java]
----
LOGGER.debug(UPDATE_MARKER, "UPDATE {} SET {}", table, values);
----

It is now possible to filter for the parent or, more specifically, only for the child marker.

[#pitfalls]
== Pitfalls

It is important to note that marker names must be unique, as Log4j registers them permanently by name. 
Developers should avoid generic marker names, as they may conflict with 
those provided by third parties. Except, of course, if the user is aware of the implications.

While it is possible to add or remove parent markers dynamically through the `setParents()' method, 
it is generally advisable to set the parents when the marker is created. 
This is for efficiency and performance reasons.

It is also worth noting that markers without parents are more efficient to evaluate 
than markers with multiple parents. It is generally a good idea to avoid 
complex hierarchies of markers where possible.
