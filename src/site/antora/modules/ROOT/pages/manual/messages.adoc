////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////
= Messages

Messages are a way to encapsulate the creation of logging statements.
They can be used to make code more readable and reuseable.

== Introduction

Log4j provides various methods for creating log messages.

The most popular ones are probably the ones that take a string as an argument:

[source, java]
----
logger.info("Hello World");
----

In simple environments, this is sufficient. However, in more complex scenarios,
the string one wants to log may require more complex construction.

Imagine a scenario that uses a `Map` and a `User` object that may look like this:

[source, java]
----
Map<String, String> map = new HashMap<>();
map.put("Name", "John Doe");

User user = new User();
user.setId("jdoe");
----

When the developer wants to log a message that says "User John Doe has logged in using id jdoe",
we can see that the string construction becomes more challenging to read:

[source, java]
----
logger.info("User {} has logged in using id {}", map.get("Name"), user.getId());
----

Messages will change your code to allow these complex constructions to be encapsulated in a class.

Developers could create a `LoggedInMessage` class that is responsible for formatting the message.
The result is more readable and reusable across the code, like the custom-made `LoggedInMessage` class:

[source, java]
----
logger.info(new LoggedInMessage(map, user));
----

== Performance and benefits

Although it may initially seem unintuitive, there is no performance benefit to using strings instead of messages. 
Ultimately, Log4j captures all log messages in a `Message` object under the hood. 
There is no difference when creating a custom `Message` object.

Testing has shown that modern JVMs can create and destroy log events quickly,
especially when complex tasks are encapsulated in the `Message` object instead of the application.

Implementing a `Layout` is also simpler with `Message` objects.
Instead of requiring the `Layout` to loop through the parameters and determine 
what to do based on the objects encountered, the `Layout` can delegate the formatting to the `Message` 
or format it based on the type of message encountered.

== Example

To achieve the same result as the previous example, we can create a `LoggedInMessage` class.
This class implements the `Message` interface and provides a `getFormattedMessage` method that returns the desired message.
The constructor can take the arguments that the `getFormattedMessage` method needs to construct the message.

[source, java]
----
public class LoggedInMessage implements Message { <1>
    private final Map<String, String> map;
    private final User user;

    public LoggedInMessage(Map<String, String> map, User user) {
        this.map = map;
        this.user = user;
    }

    @Override
    public String getFormattedMessage() { <2>
        return "User " + map.get("Name") + " has logged in using id " + user.getId(); <3>
    }
}
----
<1> The `Message` interface must be implemented.
<2> The `getFormattedMessage` provides the `String` to be logged.
<3> The message is constructed here.

Implementing a `Message` is basically only a way to concatenate a string.

With this class, the log statement can be simplified as already shown above:

[source, java]
----
logger.info(new LoggedInMessage(map, user));
----

In this example, we may create a `LoggedInMessage` object, but we will not invoke
the construction logic of this message until the `getFormattedMessage` method is called.
Logging might be turned off for this statement, and the construction logic will not be executed, saving resources.

== A more complex example

Messages can be complex, if necessary, and make them work for different scenarios.

Imagine a scenario where you want to log SQL queries and updates.
You might want to change the formatted message based on the type of SQL operation.

The first step could be to define a type for the two SQL operations.

[source,java]
----
public enum SQLType {
    UPDATE,
    QUERY
}
----

Next, we can create a `SQLMessage` class that implements the `Message` interface.
It may take the `SQLType`, the table name, and a map of query parameters as arguments. 
Based on this information, the `SQLMessage` class can format the message accordingly.

[source, java]
----
public class SQLMessage implements Message {
    private final SQLType type;
    private final String table;
    private final Map<String, String> queryParams;

    public SQLMessage(SQLType type, String table, Map<String, String> queryParams) {
        this.type = type;
        this.table = table;
        this.queryParams = queryParams;
    }

    @Override
    public String getFormattedMessage() {
        switch (type) { <1>
            case UPDATE:
                return createUpdateString();
                break;
            case QUERY:
                return createQueryString();
                break;
            default:
                throw new UnsupportedOperationException();
        }
    }

    private String createUpdateString() { <2>
        // Complex logic for creating an update log string
    }

    private String createQueryString() { <3>
        // Complex logic for creating a query log string
    }
}
----
<1> The type decides which message to create.
<2> The `createUpdateString` method creates the message for an update.
<3> The `createQueryString` method creates the message for a query.

After the logic for string creation is inserted, this message can be used
for two different scenarios already.

[source, java]
----
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import java.util.Map;

public class MyApp {
    private static final Logger logger = LogManager.getLogger();
    
    public String doQuery(String table) {
        logger.debug(new SQLMessage(SQLType.QUERY, table));
        String result = // ... do the query;
        return result;
    }

    public String doUpdate(String table, Map<String, String> params) {
        logger.debug(new SQLMessage(SQLType.UPDATE, table, params));

        String result = // ... do the query;
        return result;
    }
}
----

Even when the creation of the SQL message might be complex, the business logic is kept clean and readable.

== Message types

Log4j provides several message types that developers can use to create log messages.

[#FormattedMessage]
=== FormattedMessage

The message pattern passed to a
link:../javadoc/log4j-api/org/apache/logging/log4j/message/FormattedMessage.html[`FormattedMessage`]
is first checked to see if it is a valid `java.text.MessageFormat`
pattern. If it is, a `MessageFormatMessage` is used to format it. If not
it is next checked to see if it contains any tokens that are valid
format specifiers for `String.format()`. If so, a `StringFormattedMessage`
is used to format it. Finally, if the pattern doesn't match either of
those then a `ParameterizedMessage` is used to format it.

[#LocalizedMessage]
=== LocalizedMessage

link:../javadoc/log4j-api/org/apache/logging/log4j/message/LocalizedMessage.html[`LocalizedMessage`]
is provided primarily to provide compatibility with Log4j 1.x.
Generally, the best approach to localization is to have the client UI
render the events in the client's locale.

`LocalizedMessage` incorporates a `ResourceBundle` and allows the message
pattern parameter to be the key to the message pattern in the bundle. If
no bundle is specified, `LocalizedMessage` will attempt to locate a bundle
with the name of the Logger used to log the event. The message retrieved
from the bundle will be formatted using a FormattedMessage.

[#LoggerNameAwareMessage]
=== LoggerNameAwareMessage

`LoggerNameAwareMessage` is an interface with a `setLoggerName` method. This
method will be called during event construction so that the Message has
the name of the Logger used to log the event when the message is being
formatted.

[#MapMessage]
=== MapMessage

A `MapMessage` contains a Map of String keys and values. `MapMessage`
implements `FormattedMessage` and accepts format specifiers of "XML",
"JSON" or "JAVA", in which case the Map will be formatted as XML, JSON
or as documented by
https://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html#toString()[`java.util.AbstractMap.toString()`].
Otherwise, the Map will be formatted as `"key1=value1 key2=value2 ..."`.

Some Appenders make special use of `MapMessage` objects:

* When a JMS Appender is configured
with a no layout, it converts a Log4j `MapMessage` to a JMS
`javax.jms.MapMessage`.
* When a xref:manual/appenders.adoc#JDBCAppender[JDBC Appender] is configured
with no layout, it converts a Log4j `MapMessage` to values in a
SQL INSERT statement.
* When a xref:manual/appenders.adoc#NoSQLAppenderMongoDBMain[MongoDB Appender] is
configured with no layout, it converts a Log4j `MapMessage` to
fields in a MongoDB object.

[#MessageFormatMessage]
=== MessageFormatMessage

link:../javadoc/log4j-api/org/apache/logging/log4j/message/MessageFormatMessage.html[`MessageFormatMessage`]
handles messages that use a
https://docs.oracle.com/javase/7/docs/api/java/text/MessageFormat.html[conversion
format]. While this `Message` has more flexibility than
`ParameterizedMessage`, it is also about two times slower.

[#MultiformatMessage]
=== MultiformatMessage

A `MultiformatMessage` will have a getFormats method and a
`getFormattedMessage` method that accepts and array of format Strings. The
`getFormats` method may be called by a Layout to provide it information on
what formatting options the Message supports. The Layout may then call
`getFormattedMessage` with one or more for the formats. If the Message
doesn't recognize the format name it will simply format the data using
its default format. An example of this is `StructuredDataMessage`
which accepts a format String of "XML" which will cause it to format the
event data as XML instead of the RFC 5424 format.

[#ObjectMessage]
=== ObjectMessage

Formats an `Object` by calling its `toString` method. Since Log4j 2.6,
Layouts trying to be low-garbage or garbage-free will call the
`formatTo(StringBuilder)` method instead.

[#ParameterizedMessage]
=== ParameterizedMessage

link:../javadoc/log4j-api/org/apache/logging/log4j/message/ParameterizedMessage.html[`ParameterizedMessage`]
handles messages that contain "\{}" in the format to represent
replaceable tokens and the replacement parameters.

[#ReusableObjectMessage]
=== ReusableObjectMessage

In garbage-free mode, this message is used to pass logged Objects to the
Layout and Appenders. Functionally equivalent to
<<ObjectMessage>>.

[#ReusableParameterizedMessage]
=== ReusableParameterizedMessage

In garbage-free mode, this message is used to handle messages that
contain "\{}" in the format to represent replaceable tokens and the
replacement parameters. Functionally equivalent to
<<ParameterizedMessage>>.

[#ReusableSimpleMessage]
=== ReusableSimpleMessage

In garbage-free mode, this message is used to pass logged `String`s and
`CharSequence`s to the Layout and Appenders. Functionally equivalent to
<<SimpleMessage>>.

[#SimpleMessage]
=== SimpleMessage

`SimpleMessage` contains a `String` or `CharSequence` that requires no
formatting.

[#StringFormattedMessage]
=== StringFormattedMessage

link:../javadoc/log4j-api/org/apache/logging/log4j/message/StringFormattedMessage.html[`StringFormattedMessage`]
handles messages that use a
https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax[conversion
format] that is compliant with
https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#format(java.lang.String,%20java.lang.Object...)[java.lang.String.format()].
While this Message has more flexibility than `ParameterizedMessage`, it is
also 5 to 10 times slower.

[#StructuredDataMessage]
=====StructuredDataMessage

link:../javadoc/log4j-api/org/apache/logging/log4j/message/StructuredDataMessage.html[`StructuredDataMessage`]
allows applications to add items to a `Map` as well as set the id to allow
a message to be formatted as a Structured Data element in accordance
with http://tools.ietf.org/html/rfc5424[RFC 5424].

[#ThreadDumpMessage]
=== ThreadDumpMessage

A ThreadDumpMessage, if logged, will generate stack traces for all
threads. The stack traces will include any locks that are held.

[#TimestampMessage]
=== TimestampMessage

A TimestampMessage will provide a `getTimestamp` method that is called
during event construction. The timestamp in the Message will be used in
lieu of the current timestamp.
